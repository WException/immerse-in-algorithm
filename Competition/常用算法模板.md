# 常用算法模板

## 目录

- [质数判断](#质数判断)
- [前缀和(Prefix Sum)](#前缀和prefix-sum)
- [差分](#差分)
- [等差数列差分](#等差数列差分)
- [分解质因数](#分解质因数)
- [最大公约数 and 最小公倍数](#最大公约数-and-最小公倍数)
- [回溯算法](#回溯算法)
- [快速幂](#快速幂)
- [BFS，广度优先搜索](#bfs广度优先搜索)
- [排列组合](#排列组合)
- [错位排列](#错位排列)
- [拓扑排序](#拓扑排序)
- [并查集](#并查集)

### 质数判断
```java
// 大于等于5的质数一定和6的倍数相邻，1不是质数
// 判断素数的方法，已知1不是素数，在主函数中去除1即可
static boolean isPrime(int num){
	if (num == 0 || num == 1) return false;
    for (int i = 2; i <= Math.sqrt(num); i++) {
        if(num%i == 0) return false;
    }
    return true;
}
```

### 前缀和(Prefix Sum)

```java

```

### 差分

```java

```

### 等差数列差分

```java
// s:首项 e:末项 d:公差
void set(int l, int r, int s, int e, int d) {
    arr[l] += s;
    arr[l + 1] += d - s;
    arr[r + 1] -= d + e;
    arr[r + 2] += e;
}
// 两边前缀和即可还原
void build() {
    for (int i = 1; i <= n; i++) {
        arr[i] += arr[i - 1];
    }
    for (int i = 1; i <= n; i++) {
        arr[i] += arr[i - 1];
    }
}
```

### 分解质因数

```java
// 结果 ans 为不重复的质因数个数
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        long n = scan.nextLong();
        long ans = 0;
        for (long i = 2; i * i <= n; i++) {
        	if(n % i == 0) {
        		ans++;
        		while(n % i == 0) n /= i;
        	}
        }
        
        if (n > 1) ans++;
        System.out.println(ans);
        scan.close();
    }
}
```


### 最大公约数 and 最小公倍数
```java
// 求 a，b 的最大公约数
static int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}
// 求 a，b 的最小公倍数
static int lcm(int a, int b){
	return a * b / gcd(a, b);
}
```

### 回溯算法

``` c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### 快速幂
```java
long FastPower(long base, long power) {     //base是底数，power是幂数，result是结果
    long result= 1;
    while(power > 0) {
	if((power & 1) != 0) {
	    result*= base;
	    power -= 1;
	}
	base *= base;
	power >>= 1;
    }
    return result;
}
```

### BFS，广度优先搜索

```java
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Queue;
/*
使用bfs广度优先搜索
*/
public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int N=scan.nextInt(),M=scan.nextInt();
        int[][] map = new int[150][150];//地图
        int[][] flg = new int[150][150];//0-未走，1-已走
        Queue<Point> r = new LinkedList<Point>();//队列
        int[] dx = {0,1,0,-1};
        int[] dy = {1,0,-1,0};
        for(int i=1;i<=N;i++)
            for(int j=1;j<=M;j++)
                map[i][j] = scan.nextInt();
        int start_x=scan.nextInt(), start_y=scan.nextInt();//起点
        int end_x=scan.nextInt(), end_y=scan.nextInt();//终点

        //开始bfs
        Point point = new Point(start_x,start_y,0);
        r.offer(point);//起点入队
        flg[start_x][start_y] = 1;
        
        while(!r.isEmpty()){
            //判断现在队首是否在终点
            int x=r.peek().x;
            int y=r.peek().y;
            if(x==end_x && y==end_y){
                System.out.println(r.peek().step);
                return;
            }
            //四个方向试探
            for(int k=0;k<4;k++){
                int tx = x+dx[k];
                int ty = y+dy[k];
                if(map[tx][ty]==1 && flg[tx][ty]==0){
                    //入队
                    r.offer(new Point(tx,ty,r.peek().step+1));
                    flg[tx][ty] = 1;
                }
            }
            r.poll();//拓展完了需要将队首元素出队
        }
        System.out.println(-1);
        scan.close();
    }
}
class Point{
    int x;
    int y;
    int step;
    public Point(){}
    public Point(int x,int y,int step){
        this.x=x;
        this.y=y;
        this.step=step;
    }
}
```

### 排列组合
```java
static long C(long n, long m){
    long res = 1L;
    for(int i = 0; i < m; i++){
        res = res * (n - i) / (i + 1);
    }
    return res;
}
```

### 错位排列
```java
static long D(long a){
    if(a == 0 || a == 1) {
        return 0;
    }
    if(a == 2) {
        return 1;
    }
    return (a - 1) * (D(a - 2) + D(a - 1));
}
```

### 拓扑排序
```java

```

### 并查集
```java
// 来源哔哩哔哩左程云
// 测试链接 : https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372
// 这是输入输出处理效率很高的写法

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Main {

	public static int MAXN = 1000001;

	public static int[] father = new int[MAXN];

	public static int[] size = new int[MAXN];

	public static int[] stack = new int[MAXN];

	public static int n;

	public static void build() {
		for (int i = 0; i <= n; i++) {
			father[i] = i;
			size[i] = 1;
		}
	}

	// i号节点，往上一直找，找到代表节点返回！
	public static int find(int i) {
		// 沿途收集了几个点
		int size = 0;
		while (i != father[i]) {
			stack[size++] = i;
			i = father[i];
		}
		// 沿途节点收集好了，i已经跳到代表节点了
		while (size > 0) {
			father[stack[--size]] = i;
		}
		return i;
	}

	public static boolean isSameSet(int x, int y) {
		return find(x) == find(y);
	}

	public static void union(int x, int y) {
		int fx = find(x);
		int fy = find(y);
		if (fx != fy) {
			// fx是集合的代表：拿大小
			// fy是集合的代表：拿大小
			if (size[fx] >= size[fy]) {
				size[fx] += size[fy];
				father[fy] = fx;
			} else {
				size[fy] += size[fx];
				father[fx] = fy;
			}
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		while (in.nextToken() != StreamTokenizer.TT_EOF) {
			n = (int) in.nval;
			build();
			in.nextToken();
			int m = (int) in.nval;
			for (int i = 0; i < m; i++) {
				in.nextToken();
				int op = (int) in.nval;
				in.nextToken();
				int x = (int) in.nval;
				in.nextToken();
				int y = (int) in.nval;
				if (op == 1) {
					out.println(isSameSet(x, y) ? "Yes" : "No");
				} else {
					union(x, y);
				}
			}
		}
		out.flush();
		out.close();
		br.close();
	}

}
```

```c++
#include <vector>
class UnionFind {
private:
    std::vector<int> parent, rank;
public:
    UnionFind(int n) : parent(n), rank(n, 0) {
        for (int i = 0; i < n; ++i) parent[i] = i;
    }
    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]); // 路径压缩
    }
    void unite(int x, int y) {
        int rx = find(x), ry = find(y);
        if (rx == ry) return;
        if (rank[rx] < rank[ry]) parent[rx] = ry;          // 按秩合并
        else if (rank[rx] > rank[ry]) parent[ry] = rx;
        else { parent[ry] = rx; rank[rx]++; }
    }
    bool connected(int x, int y) { return find(x) == find(y); }
};
```

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]
    
    def union(self, x, y):
        rx, ry = self.find(x), self.find(y)
        if rx == ry: return
        if self.rank[rx] < self.rank[ry]:  # 按秩合并
            self.parent[rx] = ry
        elif self.rank[rx] > self.rank[ry]:
            self.parent[ry] = rx
        else:
            self.parent[ry] = rx
            self.rank[rx] += 1
    
    def is_connected(self, x, y):
        return self.find(x) == self.find(y)
```