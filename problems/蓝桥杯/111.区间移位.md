# 111.区间移位

蓝桥杯题库 [题目链接](https://www.lanqiao.cn/problems/111/learning/)。

> 2017，枚举，国赛，二分

题目的答案具有单调性，可以使用二分法来查找答案，关键是怎么写check函数。

思路是设置一个变量cover初始为0，检查在答案为mid的情况下cover是否可以覆盖全部区间，也就是cover >= 20000。

已知区间D[a, b]的可移动范围是D[a-mid, b+mid]。先对所有的区间根据右端点排序，初始覆盖区域为[0, 0]之后不断尝试取出可以拼接到已覆盖的区间上的点。最后判断cover是否可以覆盖全部区间。

注意：
1. 要设置一个变量flg，用于判断是否还有区间可以取出拼接。如果没有可以拼接的区间，则返回false。
2. 结果可能有小数 .5 出现。需要做相应处理，比如开始将区间端点乘2。


### C++代码
```cpp
```

### Java代码
```Java
import java.util.*;

public class Main {
    private static int[][] nodes;

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        nodes = new int[n][2];
        for (int i = 0; i < n; i++) {
            nodes[i][0] = 2 * scan.nextInt();
            nodes[i][1] = 2 * scan.nextInt();
        }
        
        Arrays.sort(nodes, Comparator.comparingInt(i -> i[1]));

        int left = 0, right = 20000;
        while (left < right) {
            int mid = (left + right) >>> 1;
            if (check(mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        if (right % 2 == 0) {
            System.out.println(right / 2);
        } else {
            System.out.println((double) right / 2);
        }
        scan.close();
    }

    private static boolean check(int shift) {
        int cover = 0;
        List<int[]> temp = new ArrayList<>(Arrays.asList(nodes));
        while (cover < 20000 && !temp.isEmpty()) {
            boolean flg = false;
            for (int i = 0; i < temp.size(); i++) {
                int[] node = temp.get(i);
                if (node[0] - shift <= cover && node[1] + shift >= cover) {
                    cover = Math.min(node[0] + shift, cover) + node[1] - node[0];
                    temp.remove(i);
                    flg = true;
                    break;
                }
            }
            if (!flg) return false;
        }
        return cover >= 20000;
    }
}
```

### Python3代码
```python
import sys

def main():
    data = sys.stdin.read().split()
    if not data:
        return
    
    n = int(data[0])
    nodes = []
    index = 1
    for i in range(n):
        x = int(data[index])
        y = int(data[index + 1])
        index += 2
        nodes.append([2 * x, 2 * y])
    
    # 按第二列升序排序
    nodes.sort(key=lambda x: x[1])
    
    def check(shift):
        cover = 0
        temp = nodes.copy()
        while cover < 20000 and temp:
            flg = False
            for i in range(len(temp)):
                node = temp[i]
                l, r = node[0], node[1]
                if l - shift <= cover and r + shift >= cover:
                    cover = min(l + shift, cover) + (r - l)
                    del temp[i]
                    flg = True
                    break
            if not flg:
                return False
        return cover >= 20000
    
    left, right = 0, 20000
    while left < right:
        mid = (left + right) >> 1
        if check(mid):
            right = mid
        else:
            left = mid + 1
    
    if right % 2 == 0:
        print(right // 2)
    else:
        print(right / 2)

if __name__ == '__main__':
    main()
```
