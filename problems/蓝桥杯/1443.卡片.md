# 1443.卡片

蓝桥杯题库 [题目链接](https://www.lanqiao.cn/problems/1443/learning/)。

> 2021, 模拟, 枚举, 省赛

## 解题思路

分析题目发现`1`是最先被消耗光的，所以只统计`1`的消耗状态就可以。

答案：3181

## 代码

### C++代码
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int count1 = 2021;  // 数字"1"的卡片数量
    int num = 1;
    
    while (count1 >= 0) {
        string str = to_string(num);
        int ones = 0;
        
        // 统计当前数字中"1"的数量
        for (char c : str) {
            if (c == '1') ones++;
        }
        
        // 检查卡片是否足够拼当前数字
        if (count1 < ones) break;
        
        // 消耗卡片
        count1 -= ones;
        num++;
    }
    
    // 退出循环时的num已无法拼出，所以输出num-1
    cout << num - 1 << endl;
    return 0;
}
```

### Java代码
```Java
public class CardPuzzle {
    public static void main(String[] args) {
        int count1 = 2021;  // 数字"1"的卡片数量
        int num = 1;
        
        while (count1 >= 0) {
            String str = Integer.toString(num);
            int ones = 0;
            
            // 统计当前数字中"1"的数量
            for (char c : str.toCharArray()) {
                if (c == '1') ones++;
            }
            
            // 检查卡片是否足够拼当前数字
            if (count1 < ones) break;
            
            // 消耗卡片
            count1 -= ones;
            num++;
        }
        
        // 退出循环时的num已无法拼出，所以返回num-1
        System.out.println(num - 1);
    }
}
```

### Python3代码
```python
def find_max():
    count_1 = 2021  # 数字"1"的卡片数量
    num = 1
    
    while count_1 >= 0:
        # 统计当前数字中"1"的数量
        ones = str(num).count('1')
        
        # 检查卡片是否足够拼当前数字
        if count_1 < ones:
            break
        
        # 消耗卡片
        count_1 -= ones
        num += 1
    
    return num - 1

print(find_max())
```

