# 20322.赛飞儿之旅【算法赛】

蓝桥杯题库 [题目链接](https://www.lanqiao.cn/problems/20322/learning/)。

> 算法赛，思维

## 题目理解

这道题的核心是：在一个 **环形跑道** 上，有编号为 `1` 到 `n` 的区域，起点在 `s` 区域，终点在 `e` 区域。你只能 **顺时针方向** 移动，每次前进一步会消耗 **1点体力**。

为了更快地到达目标，你可以选择使用 **一次瞬间移动技能**，可以瞬移到当前位置向前/向后第 `d` 格的位置，**且瞬移不消耗体力**。

你的目标是：找出一种最优策略，让你从起点 `s` 到终点 `e` 所消耗的体力值最少。


## 解题思路

我们一共有三种选择：

1. **不使用瞬移技能**，直接从 `s` 顺时针移动到 `e`。
2. **使用向前瞬移**：从 `s` 向前瞬移 `d` 格，到达 `s1`，然后从 `s1` 顺时针移动到 `e`。
3. **使用向后瞬移**：从 `s` 向后瞬移 `d` 格，到达 `s2`，然后从 `s2` 顺时针移动到 `e`。

这三种方法都合法，我们只需算出每种方法所消耗的体力值，取其中最小的那一个作为答案。

---

## 如何计算从某个点到终点要花多少体力？

在环形路径上顺时针移动，如果当前在 `s`，目标在 `e`：

* 如果 `e >= s`，那就是简单的 `e - s`。
* 如果 `e < s`，那就绕一圈，相当于 `n - s + e`。


### C++代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int getLen(int n, int s, int e) {
    if (e >= s) {
        return e - s;
    } else {
        return n - s + e;
    }
}

int main() {
    int n, s, e, d;
    cin >> n >> s >> e >> d;

    // 不瞬移
    int a = getLen(n, s, e);

    // 向前瞬移
    int s1 = (s + d <= n) ? (s + d) : (s + d - n);
    int b = getLen(n, s1, e);

    // 向后瞬移
    int s2 = (s - d >= 0) ? (s - d) : (n + (s - d));
    int c = getLen(n, s2, e);

    cout << min({a, b, c}) << endl;
    return 0;
}
```

### Java代码
```Java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int s = scan.nextInt();
        int e = scan.nextInt();
        int d = scan.nextInt();

        // 不瞬移
        int a = getLen(n, s, e);
        
        // 向前瞬移后的起点s1
        int s1 = 0;
        if (s + d <= n) {
            s1 = s + d;
        } else {
            s1 = s + d - n;
        }
        int b = getLen(n, s1, e);

        // 向后瞬移后的起点s2
        int s2 = 0;
        if (s - d >= 0) {
            s2 = s - d;
        } else {
            s2 = n + (s - d);
        }
        int c = getLen(n, s2, e);

        System.out.println(Math.min(Math.min(a, b), c));
        scan.close();
    }

    public static int getLen(int n, int s, int e) {
        int res = 0;
        if (e >= s) {
            res = e - s;
        } else {
            res = n - s + e;
        }
        return res;
    }
}
```

### Python3代码
```python
def get_len(n, s, e):
    if e >= s:
        return e - s
    else:
        return n - s + e

n, s, e, d = map(int, input().split())

# 不瞬移
a = get_len(n, s, e)

# 向前瞬移
s1 = s + d if s + d <= n else s + d - n
b = get_len(n, s1, e)

# 向后瞬移
s2 = s - d if s - d >= 0 else n + (s - d)
c = get_len(n, s2, e)

print(min(a, b, c))

```

