# 20324.blue密钥【算法赛】

蓝桥杯题库 [题目链接](https://www.lanqiao.cn/problems/20324/learning/)。

> 算法赛，模拟，思维，字符串

### 题目简化版：

给你一个只包含小写字母的字符串 `s`，你可以无限次执行以下操作：

> 交换第 `i` 位 和 `i+4` 位的字符（1 ≤ i ≤ |s| - 4）

你可以任意次使用这个操作，请问**最多能拼出多少个 "blue" 子串**？

---

### 关键限制

你不能任意打乱整个字符串，只能交换下标 `i` 和 `i+4` 的字符。

这意味着：

* **字符只会在它原来下标模 4 相同的组里流动**
* 比如下标是 `0, 4, 8, 12...` 的字符可以互换
* 下标是 `1, 5, 9, 13...` 的字符可以互换
* 所以我们把字符串划分成 4 个组：group\[0], group\[1], group\[2], group\[3]

---

### 解题思路

我们要从这 4 个组中，分别凑出一个个 "blue"：

* "b" → 来自 group\[x % 4]
* "l" → 来自 group\[(x+1) % 4]
* "u" → 来自 group\[(x+2) % 4]
* "e" → 来自 group\[(x+3) % 4]

所以我们需要枚举所有 4 种起始位置 `x = 0 ~ 3`，看看能组成多少个 "blue"，最后累加。

### 注意边界情况

如果正好字符串被完美划分成若干个 "blue"，但起始点不是 0，还要减去一个。


### C++代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int nums[4][128], num;
vector<int> ans(4, 1e9);

int main() {
    string s, s1 = "blue";
    cin >> s;

    for (int i = 0; i < s.size(); i++)
        for (int j = 0; j < 4; j++)
            if (s[i] == s1[j])
                nums[i % 4][s1[j]]++;

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++)
            ans[i] = min(ans[i], nums[(i + j) % 4][s1[j]]);
        num += ans[i];
    }

    if (num * 4 == s.size() && num != ans[0]) num--;
    cout << num;
    return 0;
}
```

### Java代码
```Java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String pattern = "blue";
        int[][] nums = new int[4][128];
        int[] ans = new int[4];
        Arrays.fill(ans, Integer.MAX_VALUE);

        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j < 4; j++) {
                if (s.charAt(i) == pattern.charAt(j)) {
                    nums[i % 4][pattern.charAt(j)]++;
                }
            }
        }

        int total = 0;
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                ans[i] = Math.min(ans[i], nums[(i + j) % 4][pattern.charAt(j)]);
            }
            total += ans[i];
        }

        if (total * 4 == s.length() && total != ans[0]) {
            total--;
        }

        System.out.println(total);
    }
}
```

### Python3代码
```python
from collections import Counter

def solve(s):
    s1 = "blue"
    nums = [Counter() for _ in range(4)]
    ans = [float('inf')] * 4
    total = 0

    # 分组统计
    for i, ch in enumerate(s):
        if ch in s1:
            nums[i % 4][ch] += 1

    # 遍历4种起始偏移
    for i in range(4):
        min_count = float('inf')
        for j in range(4):
            c = s1[j]
            min_count = min(min_count, nums[(i + j) % 4][c])
        ans[i] = min_count
        total += min_count

    # 边界修正
    if total * 4 == len(s) and ans[0] != total:
        total -= 1

    print(total)

# 示例输入
s = input().strip()
solve(s)
```

